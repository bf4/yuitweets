#!/usr/bin/env ruby

# This is currently just a stupid executable that grabs the latest unseen
# Twitter search results for [yui] and shoves them into the YUITweets database.

require 'open-uri'
require 'trollop'
require 'yajl'

require 'yuitweets'

module YUITweets::CLI
  TWITTER_URL = 'http://search.twitter.com/search.json?q=yui%20OR%20yuilibrary%20OR%20yui3%20OR%20yuiconf%20OR%20yuiconf2010&lang=en&rpp=100&result_type=recent'
  USER_AGENT  = "YUITweets/#{YUITweets::VERSION} (+http://github.com/rgrove/yuitweets/)"

  # Attempts to classify unknown tweets.
  def self.classify_tweets
    count = 0

    YUITweets::Tweet.recent({'type' => nil}, {:limit => 200}).each do |tweet|
      if type = YUITweets.bayes.classify(tweet.specimen)
        tweet.update({'$set' => {'type' => type}}, false)
        count += 1
      end
    end

    puts "Classified #{count} tweet(s)"
  end

  # Fetches new tweets.
  def self.fetch_tweets
    retries = 0
    url     = "#{TWITTER_URL}&since_id=#{YUITweets::Tweet.last_id}"

    puts "--> Fetching new tweets..."

    begin
      tweets = YUITweets.db['tweets']

      open(url, 'User-Agent' => USER_AGENT) do |search|
        count  = 0
        search = Yajl::Parser.parse(search)

        search['results'].each do |tweet|
          # Dumb insert; doesn't check to see if the tweet already exists, but
          # nothing bad will happen if it does (the insert will just fail
          # quietly since we're not checking for an error).
          tweet['_id'] = tweet['id_str']
          tweets.insert(tweet)
          count += 1
        end

        puts "Added #{count} new tweet(s)"
      end

    rescue OpenURI::HTTPError => ex
      # Twitter will return a 403 error if the since_id is too old, so we'll
      # retry once without it.
      if retries == 0
        puts "--> HTTP error; retrying one time..."
        retries += 1
        url = TWITTER_URL
        retry
      end

      raise ex
    end
  end

  def self.import(uri)
    # TODO: convert to mongo
    # db     = YUITweets.db
    # source = Sequel.connect(uri, :charset => 'utf8')
    # 
    # token_count = 0
    # tweet_count = 0
    # 
    # db.transaction do
    #   puts "--> Importing tokens..."
    # 
    #   source[:tokens].each do |row|
    #     next if db[:tokens].filter(:type => row[:type], :token => row[:token]).count > 0
    # 
    #     db[:tokens].insert(
    #       :token => row[:token],
    #       :type  => row[:type],
    #       :count => row[:count]
    #     )
    # 
    #     token_count += 1
    #   end
    # 
    #   puts "--> Importing tweets..."
    # 
    #   source[:tweets].each do |row|
    #     next if db[:tweets].filter(:id => row[:id]).count > 0
    # 
    #     db[:tweets].insert(
    #       :id         => row[:id],
    #       :tweet      => row[:tweet],
    #       :created_at => row[:created_at],
    #       :type       => row[:type],
    #       :votes      => row[:votes]
    #     )
    # 
    #     tweet_count += 1
    #   end
    # end
    # 
    # puts "Imported #{token_count} token(s) and #{tweet_count} tweet(s)."
  end

  def self.tidy
    # TODO: convert to mongo
    # tokens = YUITweets.db['tokens']
    # 
    # # Delete any tokens in the database that are in the stopwords list. This
    # # keeps things clean even if the list is modified after tokens are added.
    # tokens_deleted = 0
    # 
    # YUITweets::Config::STOPWORDS.each do |word|
    #   tokens_deleted += tokens.find({})
    #   tokens_deleted += db[:tokens].filter("LOWER(token) = ?", word).delete
    # end
    # 
    # if tokens_deleted > 0
    #   puts "--> Deleted #{tokens_deleted} token(s)."
    # end
  end

  # Parse command-line options.
  options = Trollop.options do
    version "YUITweets #{YUITweets::VERSION}"
    banner <<-EOS
Usage:
  yuitweets [options]

Options:
EOS

    opt :import, "Import from another database at the specified URI.", :short => '-i', :type => String
    opt :tidy,   "Tidy up the database.", :short => '-t'
  end

  YUITweets.init

  if options[:import_given]
    import(options[:import])

  elsif options[:tidy_given]
    tidy

  else
    fetch_tweets
    classify_tweets
  end
end
