#!/usr/bin/env ruby

# This is currently just a stupid executable that grabs the latest unseen
# Twitter search results for [yui] and shoves them into the YUITweets database.

require 'open-uri'
require 'trollop'

require 'yuitweets'

module YUITweets::CLI
  TWITTER_URL = 'http://search.twitter.com/search.json?q=yui%20OR%20yuilibrary%20OR%20yui3&lang=en&rpp=100&result_type=recent'

  # Attempts to classify unknown tweets.
  def self.classify_tweets
    count = 0

    YUITweets::Tweet.recent(:type => nil, :limit => 100).all.each do |tweet|
      if type = YUITweets.bayes.classify(tweet.specimen)
        tweet.update(:type => type)
        count += 1
      end
    end

    puts "Classified #{count} tweet(s)"
  end

  # Fetches new tweets.
  def self.fetch_tweets
    open("#{TWITTER_URL}&since_id=#{YUITweets::Tweet.last_id}") do |search|
      count  = 0
      search = Yajl::Parser.parse(search, :symbolize_keys => true)

      search[:results].each do |tweet|
        unless YUITweets.db[:tweets].filter(:id => tweet[:id]).count > 0
          # Discard fields we aren't interested in.
          tweet.delete(:metadata)

          YUITweets.db[:tweets].insert(
            :id         => tweet[:id],
            :tweet      => Yajl::Encoder.encode(tweet),
            :created_at => Time.parse(tweet[:created_at])
          )

          count += 1
        end
      end

      puts "Added #{count} new tweet(s)"
    end
  end

  def self.tidy
    db = YUITweets.db

    # Delete any tokens in the database that are in the stopwords list. This
    # keeps things clean even if the list is modified after tokens are added.
    tokens_deleted = 0

    db.transaction do
      YUITweets::Config::STOPWORDS.each do |word|
        tokens_deleted += db[:tokens].filter("LOWER(token) = ?", word).delete
      end
    end

    if tokens_deleted > 0
      puts "--> Deleted #{tokens_deleted} token(s)."
    end

    # Vacuum SQLite databases to reclaim unused space and defragment the data.
    if db.is_a?(Sequel::SQLite::Database)
      db.run('VACUUM')
      puts "--> Vacuumed and defragmented the database."
    end
  end

  # Parse command-line options.
  options = Trollop.options do
    version "YUITweets #{YUITweets::VERSION}"
    banner <<-EOS
Usage:
  yuitweets [options]

Options:
EOS

    opt :fix, "Fix votes."
    opt :tidy, "Tidies up the database.", :short => '-t'
  end

  YUITweets.init

  if options[:tidy_given]
    tidy
  else
    fetch_tweets
    classify_tweets
  end
end
