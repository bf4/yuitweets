#!/usr/bin/env ruby

# This is currently just a stupid executable that grabs the latest unseen
# Twitter search results for [yui] and shoves them into the YUITweets database.

require 'open-uri'
require 'trollop'

require 'yuitweets'

module YUITweets::CLI
  TWITTER_URL = 'http://search.twitter.com/search.json?q=yui%20OR%20yuilibrary%20OR%20yui3%20OR%20yuiconf%20OR%20yuiconf2010&lang=en&rpp=100&result_type=recent'
  USER_AGENT  = "YUITweets/#{YUITweets::VERSION} (+http://github.com/rgrove/yuitweets/)"

  # Attempts to classify unknown tweets.
  def self.classify_tweets
    count = 0

    YUITweets::Tweet.recent(:type => nil, :limit => 100).all.each do |tweet|
      if type = YUITweets.bayes.classify(tweet.specimen)
        tweet.update(:type => type)
        count += 1
      end
    end

    puts "Classified #{count} tweet(s)"
  end

  # Fetches new tweets.
  def self.fetch_tweets
    retries = 0
    url     = "#{TWITTER_URL}&since_id=#{YUITweets::Tweet.last_id}"

    puts "--> Fetching new tweets..."

    begin
      open(url, 'User-Agent' => USER_AGENT) do |search|
        count  = 0
        search = Yajl::Parser.parse(search, :symbolize_keys => true)

        search[:results].each do |tweet|
          unless YUITweets.db[:tweets].filter(:id => tweet[:id]).count > 0
            # Discard fields we aren't interested in.
            tweet.delete(:metadata)

            YUITweets.db[:tweets].insert(
              :id         => tweet[:id],
              :tweet      => Yajl::Encoder.encode(tweet),
              :created_at => Time.parse(tweet[:created_at])
            )

            count += 1
          end
        end

        puts "Added #{count} new tweet(s)"
      end

    rescue OpenURI::HTTPError => ex
      # Twitter will return a 403 error if the since_id is too old, so we'll
      # retry once without it.
      if retries == 0
        puts "--> HTTP error; retrying one time..."
        retries += 1
        url = TWITTER_URL
        retry
      end

      raise ex
    end
  end

  def self.import(uri)
    db     = YUITweets.db
    source = Sequel.connect(uri, :charset => 'utf8')

    token_count = 0
    tweet_count = 0

    db.transaction do
      puts "--> Importing tokens..."

      source[:tokens].each do |row|
        next if db[:tokens].filter(:type => row[:type], :token => row[:token]).count > 0

        db[:tokens].insert(
          :token => row[:token],
          :type  => row[:type],
          :count => row[:count]
        )

        token_count += 1
      end

      puts "--> Importing tweets..."

      source[:tweets].each do |row|
        next if db[:tweets].filter(:id => row[:id]).count > 0

        db[:tweets].insert(
          :id         => row[:id],
          :tweet      => row[:tweet],
          :created_at => row[:created_at],
          :type       => row[:type],
          :votes      => row[:votes]
        )

        tweet_count += 1
      end
    end

    puts "Imported #{token_count} token(s) and #{tweet_count} tweet(s)."
  end

  def self.tidy
    db = YUITweets.db

    # Delete any tokens in the database that are in the stopwords list. This
    # keeps things clean even if the list is modified after tokens are added.
    tokens_deleted = 0

    db.transaction do
      YUITweets::Config::STOPWORDS.each do |word|
        tokens_deleted += db[:tokens].filter("LOWER(token) = ?", word).delete
      end
    end

    if tokens_deleted > 0
      puts "--> Deleted #{tokens_deleted} token(s)."
    end

    # Vacuum SQLite databases to reclaim unused space and defragment the data.
    if db.is_a?(Sequel::SQLite::Database)
      db.run('VACUUM')
      puts "--> Vacuumed and defragmented the database."
    end
  end

  # Parse command-line options.
  options = Trollop.options do
    version "YUITweets #{YUITweets::VERSION}"
    banner <<-EOS
Usage:
  yuitweets [options]

Options:
EOS

    opt :import, "Import from another database at the specified URI.", :short => '-i', :type => String
    opt :tidy,   "Tidy up the database.", :short => '-t'
  end

  YUITweets.init

  if options[:import_given]
    import(options[:import])

  elsif options[:tidy_given]
    tidy

  else
    fetch_tweets
    classify_tweets
  end
end
